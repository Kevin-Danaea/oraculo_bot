"""
Servicio de notificaciones para Grid Trading.
"""
from typing import List, Dict, Any
from datetime import datetime, timedelta
from decimal import Decimal

from app.domain.interfaces import NotificationService
from app.domain.entities import GridTrade, GridConfig
from shared.services.telegram_trading import TelegramTradingService
from shared.services.logging_config import get_logger

logger = get_logger(__name__)

class TelegramGridNotificationService(NotificationService):
    """Implementaci√≥n de notificaciones usando Telegram."""

    def __init__(self):
        """Inicializa el servicio de notificaciones."""
        self.telegram_service = TelegramTradingService()
        
        # Control de spam para res√∫menes peri√≥dicos
        self._last_summary_sent = {}
        self._summary_interval = timedelta(hours=2)  # Resumen cada 2 horas
        
        logger.info("‚úÖ TelegramGridNotificationService inicializado.")

    def send_startup_notification(self, service_name: str, features: List[str]) -> None:
        """Env√≠a notificaci√≥n de inicio del servicio."""
        try:
            features_text = "\n".join([f"‚Ä¢ {feature}" for feature in features])
            message = (
                f"üöÄ <b>{service_name} iniciado</b> üöÄ\n\n"
                f"El servicio est√° operativo con las siguientes caracter√≠sticas:\n"
                f"{features_text}\n\n"
                f"‚è∞ <i>{datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            )
            
            self.telegram_service.send_message(message)
            logger.info(f"‚úÖ Notificaci√≥n de inicio enviada para {service_name}")
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando notificaci√≥n de inicio: {e}")

    def send_error_notification(self, service_name: str, error: str) -> None:
        """Env√≠a notificaci√≥n de error."""
        try:
            message = (
                f"üö® <b>Error en {service_name}</b> üö®\n\n"
                f"Se ha producido un error:\n"
                f"<pre>{error}</pre>\n\n"
                f"‚è∞ <i>{datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            )
            
            self.telegram_service.send_message(message)
            logger.info(f"‚úÖ Notificaci√≥n de error enviada para {service_name}")
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando notificaci√≥n de error: {e}")

    def send_info_notification(self, service_name: str, message: str) -> None:
        """Env√≠a notificaci√≥n informativa (no es un error)."""
        try:
            self.telegram_service.send_message(message)
            logger.info(f"‚úÖ Notificaci√≥n informativa enviada para {service_name}")
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando notificaci√≥n informativa: {e}")

    def send_trade_notification(self, trade: GridTrade) -> None:
        """Env√≠a notificaci√≥n de una operaci√≥n completada (DESHABILITADA para evitar spam)."""
        # NOTA: Esta notificaci√≥n est√° deshabilitada para evitar spam
        # Los trades se reportan en los res√∫menes peri√≥dicos cada 2 horas
        logger.debug(f"üìä Trade completado (sin notificaci√≥n): {trade.pair} +${trade.profit:.4f}")
        pass

    def send_bot_status_notification(self, pair: str, status: str, reason: str) -> None:
        """Env√≠a notificaci√≥n de cambio de estado del bot."""
        try:
            message = f"""
ü§ñ CAMBIO DE ESTADO DEL BOT

üìä Par: {pair}
üîÑ Estado: {status}
üí≠ Raz√≥n: {reason}
‚è∞ Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
            self.telegram_service.send_message(message)
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando notificaci√≥n de estado: {e}")

    def send_grid_activation_notification(self, pair: str) -> None:
        """Env√≠a notificaci√≥n de activaci√≥n de bot de grid."""
        try:
            message = f"""
üöÄ BOT DE GRID ACTIVADO

üìä Par: {pair}
‚úÖ Estado: ACTIVO
üèóÔ∏è Grilla inicial en creaci√≥n
‚è∞ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

El bot comenzar√° a operar seg√∫n las decisiones del Cerebro.
"""
            self.telegram_service.send_message(message)
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando notificaci√≥n de activaci√≥n: {e}")

    def send_grid_pause_notification(self, pair: str, cancelled_orders: int) -> None:
        """Env√≠a notificaci√≥n de pausa de bot de grid."""
        try:
            message = f"""
‚è∏Ô∏è BOT DE GRID PAUSADO

üìä Par: {pair}
üõë Estado: PAUSADO
üö´ √ìrdenes canceladas: {cancelled_orders}
‚è∞ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

El bot se ha pausado seg√∫n decisi√≥n del Cerebro.
"""
            self.telegram_service.send_message(message)
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando notificaci√≥n de pausa: {e}")

    def send_grid_summary(self, active_bots: int, total_trades: int, total_profit: float) -> None:
        """Env√≠a resumen de actividad de grid trading."""
        try:
            message = f"""
üìä RESUMEN DE GRID TRADING

ü§ñ Bots activos: {active_bots}
üîÑ Trades ejecutados: {total_trades}
üí∞ Ganancia total: ${total_profit:.4f} USDT
‚è∞ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Resumen del ciclo de monitoreo completado.
"""
            self.telegram_service.send_message(message)
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando resumen de grid: {e}")

    def send_decision_change_notification(self, configs_with_decisions: List[tuple]) -> None:
        """
        Env√≠a notificaci√≥n cuando hay cambios de decisi√≥n en la base de datos.
        Se env√≠a una sola vez por cambio de decisi√≥n para evitar spam.
        
        Args:
            configs_with_decisions: Lista de tuplas (GridConfig, current_decision, previous_state)
        """
        try:
            if not configs_with_decisions:
                return
            
            # Filtrar solo configuraciones con cambios de decisi√≥n
            changed_configs = []
            for config, current_decision, previous_state in configs_with_decisions:
                if current_decision != previous_state and current_decision != "NO_STRATEGY":
                    changed_configs.append((config, current_decision, previous_state))
            
            if not changed_configs:
                return
            
            # Crear mensaje de notificaci√≥n
            message = "üîÑ <b>CAMBIOS DE DECISI√ìN - GRID TRADING</b>\n\n"
            
            for config, current_decision, previous_state in changed_configs:
                status_emoji = "‚úÖ" if current_decision == "RUNNING" else "‚è∏Ô∏è"
                action = "INICIADO" if current_decision == "RUNNING" else "PAUSADO"
                
                message += f"{status_emoji} <b>{config.pair}</b>\n"
                message += f"   Estado anterior: {previous_state}\n"
                message += f"   Estado actual: {current_decision}\n"
                message += f"   Acci√≥n: {action}\n"
                message += f"   Capital: ${config.total_capital:.2f} USDT\n\n"
            
            message += f"‚è∞ <i>{datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            self.telegram_service.send_message(message)
            logger.info(f"‚úÖ Notificaci√≥n de cambios de decisi√≥n enviada: {len(changed_configs)} bots")
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando notificaci√≥n de cambios de decisi√≥n: {e}")

    def send_periodic_trading_summary(self, trading_stats: Dict[str, Any]) -> bool:
        """
        Env√≠a resumen peri√≥dico de trading (cada 2 horas).
        Controla el spam verificando el intervalo de tiempo.
        
        Args:
            trading_stats: Diccionario con estad√≠sticas de trading
            
        Returns:
            bool: True si se envi√≥ la notificaci√≥n, False si no se cumpli√≥ el intervalo
        """
        try:
            now = datetime.now()
            
            # Verificar si ha pasado suficiente tiempo desde el √∫ltimo resumen
            if 'last_summary_time' in self._last_summary_sent:
                time_since_last = now - self._last_summary_sent['last_summary_time']
                if time_since_last < self._summary_interval:
                    logger.debug(f"‚è∞ Resumen peri√≥dico no enviado: faltan {self._summary_interval - time_since_last}")
                    return False
            
            # Crear mensaje de resumen
            message = "üìä <b>RESUMEN PERI√ìDICO - GRID TRADING</b>\n\n"
            
            # Balance total de la cuenta
            total_account_balance = trading_stats.get('total_account_balance', 0.0)
            message += f"üí∞ <b>Balance Total Cuenta:</b> ${total_account_balance:.2f} USDT\n\n"
            
            # Informaci√≥n general
            active_bots = trading_stats.get('active_bots', 0)
            total_trades = trading_stats.get('total_trades', 0)
            total_profit = trading_stats.get('total_profit', 0.0)
            
            message += f"ü§ñ <b>Bots Activos:</b> {active_bots}\n"
            message += f"üîÑ <b>Trades Totales:</b> {total_trades}\n"
            message += f"üí∞ <b>Ganancia Total:</b> ${total_profit:.4f} USDT\n\n"
            
            # Detalles por par
            bots_details = trading_stats.get('bots_details', [])
            if bots_details:
                message += "üìà <b>DETALLES POR PAR:</b>\n\n"
                
                for bot_detail in bots_details:
                    pair = bot_detail.get('pair', 'N/A')
                    current_price = bot_detail.get('current_price', 0.0)
                    allocated_capital = bot_detail.get('allocated_capital', 0.0)
                    capital_in_assets = bot_detail.get('capital_in_assets', 0.0)
                    capital_in_assets_locked = bot_detail.get('capital_in_assets_locked', 0.0)
                    capital_in_usdt = bot_detail.get('capital_in_usdt', 0.0)
                    buy_orders = bot_detail.get('buy_orders', 0)
                    sell_orders = bot_detail.get('sell_orders', 0)
                    has_orders = bot_detail.get('has_orders', False)
                    pnl = bot_detail.get('pnl', 0.0)
                    pnl_percent = bot_detail.get('pnl_percent', 0.0)
                    
                    pnl_emoji = "üí∞" if pnl >= 0 else "üìâ"
                    
                    message += f"üí± <b>{pair}</b>\n"
                    message += f"   üíµ Precio actual: ${current_price:.4f}\n"
                    message += f"   üè¶ Capital asignado: ${allocated_capital:.2f}\n"
                    # Mostrar capital en activos con informaci√≥n de bloqueado
                    if capital_in_assets_locked > 0:
                        message += f"   ü™ô Capital en activos: ${capital_in_assets:.2f} (bloqueado: ${capital_in_assets_locked:.2f})\n"
                    else:
                        message += f"   ü™ô Capital en activos: ${capital_in_assets:.2f}\n"
                    message += f"   üíµ Capital en USDT: ${capital_in_usdt:.2f}\n"
                    
                    # Mostrar √≥rdenes de forma m√°s clara con informaci√≥n de l√≠mite
                    if has_orders:
                        total_orders = buy_orders + sell_orders
                        # Obtener el l√≠mite de √≥rdenes del bot (asumiendo que es grid_levels)
                        grid_levels = bot_detail.get('grid_levels', 30)  # Default 30 si no est√° disponible
                        
                        if total_orders >= grid_levels:
                            message += f"   üìà √ìrdenes compra: {buy_orders}\n"
                            message += f"   üìâ √ìrdenes venta: {sell_orders}\n"
                            message += f"   üö¶ Total √≥rdenes: {total_orders}/{grid_levels} (l√≠mite alcanzado)\n"
                        else:
                            message += f"   üìà √ìrdenes compra: {buy_orders}\n"
                            message += f"   üìâ √ìrdenes venta: {sell_orders}\n"
                            message += f"   üìä Total √≥rdenes: {total_orders}/{grid_levels}\n"
                    else:
                        message += f"   ‚è∏Ô∏è Sin √≥rdenes activas\n"
                    
                    message += f"   {pnl_emoji} P&L: ${pnl:.4f} ({pnl_percent:+.2f}%)\n\n"
            
            # Informaci√≥n de riesgo
            risk_events = trading_stats.get('risk_events', {})
            if risk_events:
                stop_loss_events = risk_events.get('stop_loss', 0)
                trailing_up_events = risk_events.get('trailing_up', 0)
                
                if stop_loss_events > 0 or trailing_up_events > 0:
                    message += "üõ°Ô∏è <b>EVENTOS DE RIESGO:</b>\n"
                    message += f"   üö® Stop Loss: {stop_loss_events}\n"
                    message += f"   üìà Trailing Up: {trailing_up_events}\n\n"
            
            # üì± Informaci√≥n de √≥rdenes complementarias acumuladas
            complementary_orders_summary = trading_stats.get('complementary_orders_summary', '')
            if complementary_orders_summary:
                message += f"{complementary_orders_summary}\n\n"
            
            message += f"‚è∞ <i>{now.strftime('%H:%M:%S %d/%m/%Y')}</i>\n"
            message += f"üîÑ <i>Resumen cada 2 horas</i>"
            
            # Enviar mensaje
            self.telegram_service.send_message(message)
            
            # Actualizar timestamp del √∫ltimo resumen
            self._last_summary_sent['last_summary_time'] = now
            
            logger.info(f"‚úÖ Resumen peri√≥dico enviado: {active_bots} bots activos, ${total_profit:.4f} ganancia, Balance total: ${total_account_balance:.2f}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando resumen peri√≥dico: {e}")
            return False

    def send_risk_event_notification(self, event_type: str, pair: str, details: Dict[str, Any]) -> None:
        """
        Env√≠a notificaci√≥n espec√≠fica para eventos de riesgo (stop loss, trailing up).
        
        Args:
            event_type: 'stop_loss' o 'trailing_up'
            pair: Par de trading
            details: Detalles del evento
        """
        try:
            if event_type == 'stop_loss':
                emoji = "üö®"
                title = "STOP LOSS ACTIVADO"
                color = "üî¥"
            elif event_type == 'trailing_up':
                emoji = "üìà"
                title = "TRAILING UP ACTIVADO"
                color = "üü¢"
            else:
                return
            
            message = f"{emoji} <b>{title}</b>\n\n"
            message += f"üí± <b>Par:</b> {pair}\n"
            
            if event_type == 'stop_loss':
                last_buy_price = details.get('last_buy_price', 0)
                current_price = details.get('current_price', 0)
                drop_percent = details.get('drop_percent', 0)
                
                message += f"üìâ <b>√öltima compra:</b> ${last_buy_price:.4f}\n"
                message += f"üìä <b>Precio actual:</b> ${current_price:.4f}\n"
                message += f"üìâ <b>Ca√≠da:</b> {drop_percent:.2f}%\n"
                message += f"üõë <b>Acci√≥n:</b> Liquidaci√≥n y pausa del bot\n"
                
            elif event_type == 'trailing_up':
                highest_sell_price = details.get('highest_sell_price', 0)
                current_price = details.get('current_price', 0)
                rise_percent = details.get('rise_percent', 0)
                
                message += f"üìà <b>Nivel m√°s alto venta:</b> ${highest_sell_price:.4f}\n"
                message += f"üìä <b>Precio actual:</b> ${current_price:.4f}\n"
                message += f"üìà <b>Subida:</b> {rise_percent:.2f}%\n"
                message += f"üîÑ <b>Acci√≥n:</b> Reinicio con nuevo precio base\n"
            
            message += f"\n‚è∞ <i>{datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            self.telegram_service.send_message(message)
            logger.info(f"‚úÖ Notificaci√≥n de evento de riesgo enviada: {event_type} para {pair}")
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando notificaci√≥n de evento de riesgo: {e}")

    def set_summary_interval(self, hours: int) -> None:
        """
        Configura el intervalo para res√∫menes peri√≥dicos.
        
        Args:
            hours: N√∫mero de horas entre res√∫menes
        """
        self._summary_interval = timedelta(hours=hours)
        logger.info(f"‚úÖ Intervalo de res√∫menes configurado: {hours} horas")

    def force_send_summary(self) -> bool:
        """
        Fuerza el env√≠o de un resumen inmediatamente, ignorando el intervalo.
        √ötil para testing o solicitudes manuales.
        """
        # Limpiar timestamp para forzar env√≠o
        if 'last_summary_time' in self._last_summary_sent:
            del self._last_summary_sent['last_summary_time']
        
        logger.info("‚úÖ Forzando env√≠o de resumen inmediato")
        return True

    def send_notification(self, message: str) -> None:
        """
        Env√≠a una notificaci√≥n gen√©rica por Telegram.
        
        Args:
            message: Mensaje a enviar
        """
        try:
            self.telegram_service.send_message(message)
            logger.info("‚úÖ Notificaci√≥n gen√©rica enviada")
        except Exception as e:
            logger.error(f"‚ùå Error enviando notificaci√≥n gen√©rica: {e}")

    def send_detailed_status_notification(self, summary) -> None:
        """
        Env√≠a notificaci√≥n con el estado detallado de trading.
        
        Args:
            summary: Objeto TradingSummary con el estado detallado
        """
        try:
            message = self._format_detailed_status_message(summary)
            self.telegram_service.send_message(message)
            logger.info("‚úÖ Notificaci√≥n de estado detallado enviada")
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando notificaci√≥n de estado detallado: {e}")

    def send_restart_safety_notification(self, report) -> None:
        """
        Env√≠a notificaci√≥n con el reporte de seguridad al reiniciar.
        
        Args:
            report: Objeto RestartSafetyReport con el reporte de seguridad
        """
        try:
            message = self._format_safety_report_message(report)
            self.telegram_service.send_message(message)
            logger.info("‚úÖ Notificaci√≥n de reporte de seguridad enviada")
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando notificaci√≥n de seguridad: {e}")

    def _format_detailed_status_message(self, summary) -> str:
        """
        Formatea el resumen detallado como mensaje legible.
        
        Args:
            summary: Resumen del estado de trading
            
        Returns:
            str: Mensaje formateado
        """
        try:
            message = f"üìä **ESTADO DETALLADO DE TRADING**\n\n"
            message += f"üïê Actualizado: {summary.last_update.strftime('%H:%M:%S %d/%m/%Y')}\n"
            message += f"üí± Modo: {summary.trading_mode.upper()}\n\n"
            
            # Resumen general
            message += f"**üìà RESUMEN GENERAL**\n"
            message += f"‚Ä¢ Total de bots: {summary.total_bots}\n"
            message += f"‚Ä¢ Bots activos: {summary.active_bots} üü¢\n"
            message += f"‚Ä¢ Bots pausados: {summary.paused_bots} ‚è∏Ô∏è\n"
            message += f"‚Ä¢ Capital asignado: ${summary.total_capital_allocated:,.2f} USDT\n"
            message += f"‚Ä¢ Capital disponible: ${summary.total_capital_available:,.2f} USDT\n"
            message += f"‚Ä¢ √ìrdenes activas: {summary.total_orders_active}\n\n"
            
            # Balance del exchange
            message += f"**üí∞ BALANCE DEL EXCHANGE**\n"
            for currency, amount in summary.exchange_balance.items():
                if amount > 0:
                    message += f"‚Ä¢ {currency}: {amount:,.8f}\n"
            message += "\n"
            
            # Estado de cada bot
            message += f"**ü§ñ ESTADO DE BOTS**\n"
            for bot in summary.bots_status:
                if bot.is_active:  # Solo mostrar bots activos
                    message += f"\n**{bot.pair}** {bot.status_summary}\n"
                    message += f"‚Ä¢ Capital: ${bot.allocated_capital:,.2f} USDT\n"
                    message += f"‚Ä¢ Precio actual: ${bot.current_price:,.8f}\n"
                    message += f"‚Ä¢ Niveles: {bot.grid_levels} | Rango: {bot.price_range_percent}%\n"
                    message += f"‚Ä¢ √ìrdenes activas: {bot.active_orders_count}\n"
                    message += f"‚Ä¢ √öltima decisi√≥n: {bot.last_decision}\n"
            
            return message
            
        except Exception as e:
            logger.error(f"‚ùå Error formateando mensaje de estado: {e}")
            return f"‚ùå Error generando estado detallado: {e}"

    def _format_safety_report_message(self, report) -> str:
        """
        Formatea el reporte de seguridad como mensaje legible.
        
        Args:
            report: Reporte de seguridad
            
        Returns:
            str: Mensaje formateado
        """
        try:
            message = f"üîí **REPORTE DE SEGURIDAD AL REINICIAR**\n\n"
            
            # Resumen general
            message += f"**üìä RESUMEN GENERAL**\n"
            message += f"‚Ä¢ √ìrdenes canceladas: {report.total_orders_cancelled}\n"
            message += f"‚Ä¢ Capital faltante total: ${report.total_missing_capital:,.2f} USDT\n"
            message += f"‚Ä¢ Capital excedente total: ${report.total_excess_capital:,.2f} USDT\n"
            message += f"‚Ä¢ Seguro para continuar: {'‚úÖ S√ç' if report.is_safe_to_continue else '‚ùå NO'}\n\n"
            
            # Verificaciones por par
            message += f"**üí∞ VERIFICACI√ìN POR PAR**\n"
            for verification in report.capital_verifications:
                message += f"\n**{verification.pair}**\n"
                message += f"‚Ä¢ Capital asignado: ${verification.allocated_capital:,.2f} USDT\n"
                message += f"‚Ä¢ Balance USDT: ${verification.actual_balance_usdt:,.2f}\n"
                message += f"‚Ä¢ Balance {verification.pair.split('/')[0]}: {verification.actual_balance_crypto:,.8f}\n"
                message += f"‚Ä¢ Valor total: ${verification.total_value:,.2f} USDT\n"
                
                if verification.missing_capital > 0:
                    message += f"‚Ä¢ ‚ö†Ô∏è Capital faltante: ${verification.missing_capital:,.2f}\n"
                if verification.excess_capital > 0:
                    message += f"‚Ä¢ üí∞ Capital excedente: ${verification.excess_capital:,.2f}\n"
                
                message += f"‚Ä¢ Estado: {'‚úÖ SEGURO' if verification.is_safe else '‚ùå INSEGURO'}\n"
            
            # Recomendaciones
            if report.recommendations:
                message += f"\n**üí° RECOMENDACIONES**\n"
                for rec in report.recommendations:
                    message += f"‚Ä¢ {rec}\n"
            
            return message
            
        except Exception as e:
            logger.error(f"‚ùå Error formateando reporte de seguridad: {e}")
            return f"‚ùå Error generando reporte de seguridad: {e}" 